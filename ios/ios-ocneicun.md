## 【iOS沉思录】iOS内存管理试题总结与详解

> 原文链接:http://blog.csdn.net/cordova/article/details/60958978

---
> ### iOS中的GC垃圾回收机制与内存管理机制以及block

### 问题：僵尸对象、野指针、空指针分别指什么，有什么区别？
> 
- 僵尸对象：一个OC对象引用计数为0被释放后就变成僵尸对象了，僵尸对象的内存已经被系统回收，虽然可能该对象还存在，数据依然在内存中，但僵尸对象已经是不稳定对象了，不可以再访问或者使用，它的内存是随时可能被别的对象申请而占用的；
>
- 野指针：野指针出现的原因是指针没有赋值，或者指针指向的对象已经被释放掉了，野指针指向一块随机的垃圾内存，向他们发送消息会报EXC_BAD_ACCESS错误导致程序崩溃；
>
- 空指针：空指针不同于野指针，它是一个没有指向任何东西的指针，空指针是有效指针，值为nil、NULL、Nil或0等，给空指针发送消息不会报错，只是不响应消息而已，应该给野指针及时赋予零值变成有效的空指针，避免内存报错。

### 问题： Objective-C有GC垃圾回收机制吗？
>  
GC(Garbage Collection)，垃圾回收机制，简单地说就是程序中及时处理废弃不用的内存对象的机制，防止内存中废弃对象堆积过多造成内存泄漏。Objective-C语言本身是支持垃圾回收机制的，但有平台局限性，仅限于Mac桌面系统开发中，而在iPhone和iPad等苹果移动终端设备中是不支持垃圾回收机制的。在移动设备开发中的内存管理是采用MRC(Manual Reference Counting)以及iOS5以后的ARC(Automatic Reference Counting)，本质都是RC引用计数，通过引用计数的方式来管理内存的分配与释放，从而防止内存泄漏。
> 
另外引用计数RC和垃圾回收GC是有区别的。垃圾回收是宏观的，对整体进行内存管理，虽然不同平台垃圾回收机制有异，但基本原理都是一样的：将所有对象看做一个集合，然后在GC循环中定时检测活动对象和非活动对象，及时将用不到的非活动对象释放掉来避免内存泄漏，也就是说用不到的垃圾对象是交给GC来管理释放的，而无需开发者关心，典型的是Java中的垃圾回收机制；相比于GC，引用计数是局部性的，开发者要管理控制每个对象的引用计数，单个对象引用计数为0后会马上被释放掉。ARC自动引用计数则是一种改进，由编译器帮助开发者自动管理控制引用计数(自动在合适的时机发送release和retain消息)。另外自动释放池autorelease pool则像是一个局部的垃圾回收，将部分垃圾对象集中释放，相对于单个释放会有一定延迟。

### 相关问题： 自动释放池跟GC(垃圾回收)有什么区别？
- iPhone上有GC么？
- [pool release]和[pool drain]有什么区别？

> 
[pool release]和[pool drain]在作用上是一样的，都是倾倒自动释放池，区别是drain在支持GC垃圾回收的系统中(Mac系统)可以引起GC回收操作，而release不可以。对于自动释放池一般还是使用[pool drain]了，一是它的功能对系统兼容性更强，二者也是为了跟普通对象的release释放区别开。自动释放池的释放操作指的是向池内所有的对象发送release消息，以让系统及时释放池内的所有对象。

### 问题： 如果一个对象释放前被加到了NotificationCenter中，不在NotificationCenter中remove这个对象可能会出现什么问题？
> 
首先对于NotificationCenter的使用，我们都知道，只要添加对象到消息中心进行通知注册，之后就一定要对其remove进行通知注销。将对象添加到消息中心后，消息中心只是保存该对象的地址，消息中心到时候会根据地址发送通知给该对象，但并没有取得该对象的强引用，对象的引用计数不会加1。如果对象释放后却没有从消息中心remove掉进行通知注销，也就是通知中心还保存着那个指针，而那个指针指的对象可能已经被释放销毁了，那个指针就成为一个野指针，当通知发生时，会向这个野指针发送消息导致程序崩溃。

### 问题：Objective-C是如何实现内存管理的？
> autorealease pool自动释放池是什么？
autorelease的对象是在什么时候被release的？
autorelease和release有什么区别？

- 引用计数
>
Objective-C的内存管理本质上是通过引用计数实现的，每次RunLoop都会检查对象的引用计数，如果引用计数为0，说明该对象已经没人用了，可以对其进行释放了。其中引用计数可以大体分为三种：MRC(手动内存计数)、ARC(自动内存计数，iOS5以后)和内存池。

其中引用计数是如何操作的呢？不论哪种引用计数方式，本质都是在合适的时机将对象的引用计数加1或者减1。

这里简单归结一下：
```
使对象引用计数加1的常见操作有：`alloc`、`copy`、`retain`
使对象引用计数减1的常见操作有：`release`、`autorealease`
```
- 自动释放池

```
自动释放池是一个统一来释放一组对象的容器，在向对象发送autorelease消息时，对象并没有立即释放，而是将对象加入到最新的自动释放池（即将该对象的引用交给自动释放池，之后统一调用release），自动释放池会在程序执行到作用域结束的位置时进行drain释放操作，这个时候会对池中的每一个对象都发送release消息来释放所有对象。这样其实就实现了这些对象的延迟释放。

自动释放池释放的时机，也就是自动释放池内的所有对象是在什么时候释放的，这里要提到程序的运行周期RunLoop。对于每一个新的RunLoop，系统都会隐式的创建一个autorelease pool，RunLoop结束时自动释放池便会进行对象释放操作。

 autorelease和release的区别主要是引用计数减一的时机不同,autorelease会在对象的使用真正结束的时候才做引用计数减1，而不是收到消息立马释放。
```
---

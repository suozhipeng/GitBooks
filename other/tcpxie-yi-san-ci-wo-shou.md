# TCP三次握手详解及释放连接过程

原文链接：[http://blog.csdn.net/oney139/article/details/8103223](http://blog.csdn.net/oney139/article/details/8103223)

---

TCP头部： 其中 ACK   SYN  序号  这三个部分在以下会用到，它们的介绍也在下面。  


![](http://img.my.csdn.net/uploads/201210/23/1350984283_5857.jpg)

暂时需要的信息有：

ACK： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

SYN\(SYNchronization\) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。

FIN（finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
![](http://img.my.csdn.net/uploads/201210/23/1350984685_4221.jpg)

  
**三次握手的过程**：

![](http://img.my.csdn.net/uploads/201210/23/1350985085_3123.jpg)

首先由Client发出请求连接即 SYN=1 ACK=0  \(请看头字段的介绍\), TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x

然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1,

再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.

然后连接建立，为什么要进行三次握手呢（两次确认）。

![](http://img.my.csdn.net/uploads/201210/23/1350985432_2318.jpg)

**下面是释放连接的过程：**
![](http://img.my.csdn.net/uploads/201210/23/1350990937_5362.jpg)  


当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1\(如图）， A收到后回复一个确认信息，并进入 TIME\_WAIT 状态， 等待 2MSL 时间。

为什么要等待呢？

为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT\_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT\_TIME会重新记时）

另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。  

---
**【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？**  
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。  
**【问题2】为什么TIME\_WAIT状态需要经过2MSL\(最大报文段生存时间\)才能返回到CLOSE状态？**  
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME\_WAIT状态就是用来重发可能丢失的ACK报文。

